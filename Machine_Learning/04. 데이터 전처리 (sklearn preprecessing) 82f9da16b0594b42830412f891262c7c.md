# 데이터 전처리 (sklearn.preprecessing)

- **데이터 인코딩**
    - 레이블
    - 원-핫 인코딩
- **스케일링**
    - StandardScaler (표준화)
    - MinMaxScaler(정규화)

- 데이터 클렌징
- 결손값 처리
- 이상치 제거
- Feature 선택, 추출 및 가공

# 데이터 인코딩

1. **레이블 인코딩**
    1. 문자열→ 숫자열로 인코딩하기 좋음
    2. 각 레이블에 고유의 숫자를 매길때 (1,2,3,4,5..)
    
    ```python
    **from sklearn.preprocessing import LabelEncoder**
    
    items=['TV','냉장고','전자레인지','컴퓨터','선풍기','선풍기','믹서','믹서']
    
    encoder =LabelEncoder()
    encoder.**fit**(items) # 문자열 학습
    labels = encoder.**transform**(items) # items 리스트를 인코딩. 모든 문자열을 fit에서 학습된 매핑 방법에 따라 인코딩된 정수값으로 변환.
    labels
    
    >>> 결과
    array([0, 1, 4, 5, 3, 3, 2, 2])
    
    ```
    
    # **fit함수**는 items 리스트에 있는 고유한 문자열을 찾아냄.TV를 0, 냉장고를 1, 전자레인지를 2, 컴터를 3, 선풍기를 4, 믹서를 5로 매팽할 방법을 학습함.
    
    #**transform 함수**는 items 리스트의 값들을 이전에 학습된 방법에 따라 인코딩. tv→0, 냉장고 →1, 전자레인지→2…..로 인코딩.
    
    **디코딩**
    
    ```python
    encoder.**inverse_transform**([0, 1, 4, 5, 3, 3, 2, 2])
    ```
    
2. **원-핫 인코딩**
    - 언제 사용?
        - 0과 1으로만 분리할 때(와인: 레드와인(0), 화이트와인(1))
        - 분류 문제에서 범주형 변수를 처리할 때
        - 비선형 데이터를 처리할 떄
        - 인코딩된 범주형 데이터를 다른 모델에 입력으로 사용할
    - 방법1
        1. 내가 표현하고 싶은 것만 1로 나머진 0으로
        2. 다중 공선성이 발생할 수도. 따라서 원핫 인코딩통해 생성된 column 중 하나를 삭제하고 모델을 만들어주면 됨. 즉 column이 n개 생성되었을 때 n-1개만 사용
            
            ```python
            **from sklearn.preprocessing import OneHotEncoder**
            
            oh_encoder = OneHotEncoder()
            items=['TV','냉장고','전자레인지','컴퓨터','선풍기','선풍기','믹서','믹서']
            items = np.array(items).**reshape(-1,1)
            # OneHotEncoder 클래스는 입력 데이터로  2차원 배열을 받음. 
            # 따라서 list인 item을 1차원 array형태로 바꾸고, reshape를 통해 2차원으로 변환**
            
            oh_encoder.**fit**(items)
            oh_labels =oh_encoder.**transform**(items)
            
            #oh_labels(원핫인코더로 변환한 결과는 **'희소행렬'**)
            	# 따라서 toarray()를 이용해 '**밀집행렬'**로 변환
            
            oh_labels.**toarray**()
            
            >>>결과
            array([[1., 0., 0., 0., 0., 0.],
                   [0., 1., 0., 0., 0., 0.],
                   [0., 0., 0., 0., 1., 0.],
                   [0., 0., 0., 0., 0., 1.],
                   [0., 0., 0., 1., 0., 0.],
                   [0., 0., 0., 1., 0., 0.],
                   [0., 0., 1., 0., 0., 0.],
                   [0., 0., 1., 0., 0., 0.]])
            ```
            

- 방법2: g**et_dummies()**
    1. 판다스에서 원핫인코딩을 더 쉽게 지원하는 API
    
    ```python
    import pandas as pd
    
    items=['TV','냉장고','전자레인지','컴퓨터','선풍기','선풍기','믹서','믹서']
    
    df= pd.DataFrame({'item':['TV','냉장고','전자레인지','컴퓨터','선풍기','선풍기','믹서','믹서']})
    pd.**get_dummies**(df)
    ```
    
    ![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20(sklearn%20preprecessing)%2082f9da16b0594b42830412f891262c7c/Untitled.png)
    
- 방법3:
    
    ```python
    **from sklearn.compose import ColumnTransformer**
    from sklearn.preprocessing import OneHotEncoder
    
    ct = ColumnTransformer(
    					transformers=[('encoder',OneHotEncoder(drop='first'),[2])],remainder = 'passthrough')
    		 # drop='first' 첫번째 열은 자르겠다. [2]: 2인덱스를 변환해주시오.
    X = ct.fit_transform(X)
    X
    ```
    

# 피처 스케일링

1. **StandardScaler(표준화)**
    1. 데이터의 분포를 통일 할 때 사용
    2. 평균은 0, 표준편차는 1로 변환
    3. 선형회귀, 로지스틱 회귀, 서포트벡터머신
    4. 이상치 있는 경우에도 영향 적게 받
    
    ```python
    **from sklearn.preprocessing import StandardScaler**
    
    scaler = StandardScaler()
    scaler.**fit**(iris_df)
    iris_scaled = scaler.**transform**(iris_df)
    
    iris_df_scaled = pd.DataFrame(data=iris_scaled, columns = iris.feature_names)
    print('featrue평균값')
    print(iris_df_scaled.mean())
    print()
    print('feature 분산값')
    print(iris_df_scaled.var())
    ```
    

- 결과
    - **기존 iris_df**
        
        ![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20(sklearn%20preprecessing)%2082f9da16b0594b42830412f891262c7c/Untitled%201.png)
        
        ![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20(sklearn%20preprecessing)%2082f9da16b0594b42830412f891262c7c/Untitled%202.png)
        
    
    - **iris_df_scaled**
        
        ![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20(sklearn%20preprecessing)%2082f9da16b0594b42830412f891262c7c/Untitled%203.png)
        
        ![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20(sklearn%20preprecessing)%2082f9da16b0594b42830412f891262c7c/Untitled%204.png)
        

1. **MinMaxScaler**
    1. 단위가 다르고 **최대최소**가 존재하는 경우
    2. 최소값을0, 최대값을 1로 변환하는 
    3. 최대최소가 존재한다? = 데이터의 범위가 정해져 있다.
    4. ex) 영화 평점 (네이버:1~10, 넷플: 1~5)
    5. 이미지 처리, neural network
        1. 이미지 처리: 각 픽셀값 0~255 사이. 따라서 이러한 데이터를 신경망 모델에 입력하기 전에 0~1사이로 스케일링 하여 입력할 수 있음.
    6. 이상치 많을 땐 적합하지 않음
    
    ```python
    **from sklearn.preprocessing import MinMaxScaler**
    
    scaler = MinMaxScaler()
    scaler.**fit**(iris_df)
    iris_scaled = scaler.**transform**(iris_df)
    
    iris_df_scaled = pd.DataFrame(data= iris_scaled, columns= iris.feature_names)
    print('feature들의 최소값')
    print(iris_df_scaled.min())
    
    print('feature들의 최대값')
    print(iris_df_scaled.max())
    ```
    
2. **스케일러 사용 시 주의사항**
    1. 가능하면 전체 데이터의 스케일링 변환 후 학습, 테스트 데이터로 분리하기
    2. 1이 여의치 않다면 
        
        학습데이터에만 fit, transform사용 후
        
        테스트 데이터 변환시에는 학습데이터로 이미 fit()이 된 scaler 객체를 이용해 transform()으로 변환
        
        ```python
        scaler =MinMaxScaler()
        scaler.**fit**(train_array)
        train_scaled = scaler.**transform**(train_array)
        
        test_scaled = scaler.**transform**(test_array) 
        ```
        

Standard